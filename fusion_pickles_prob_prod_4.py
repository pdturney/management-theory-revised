#
# Fusion Pickles Probability * Productivity 4 Parts
#
# Peter Turney, July 14, 2021
#
# From the 20 runs, extract all of the pickled four-part seeds
# that are stored in the 20 "fusion_storage.bin" pickle files.
# Read the pickles and run each pickle, recording the results in
# a numpy tensor:
#
# tensor = num_seeds x num_steps x num_colours x num_parts
#
# num_seeds   = to be determined
# num_steps   = 1001
# num_colours = 5 (white, red, orange, blue, green)
# num_parts   = 4
#
# After this tensor has been filled with values, generate
# a table of the form:
#
# <prob * prod N M> = <probability * productivity for N managers and M workers>
#
# row in table = <step number> <p*p 4 0> <p*p 3 1> <p*p 2 2> <p*p 1 3> <p*p 0 4>
#
import golly as g
import model_classes as mclass
import model_functions as mfunc
import model_parameters as mparam
import numpy as np
import scipy.stats as st
import copy
import time
import pickle
import os
import re
import sys
#
# Parameter values for making the graphs.
#
max_seeds   = 2000 # probably won't need more seeds than this
num_steps   = 1001 # number of time steps in the game
num_colours = 5    # 5 colours [white, red, blue, orange, green]
num_parts   = 4    # number of parts
num_files   = 20   # number of fusion pickle files
step_size   = 20   # number of time steps between each plot point
#
# Location of fusion_storage.bin files -- the input pickles.
#
fusion_dir = "C:/Users/peter/Peter's Projects" + \
             "/management-theory-revised/Experiments"
# list of pickle files
fusion_files = []
# loop through the fusion files and record the file paths
# -- we assume the folders have the form "run1", "run2", ...
for i in range(num_files):
  fusion_files.append(fusion_dir + "/run" + str(i + 1) + \
    "/fusion_storage.bin")
#
# Loop through the pickles, loading them into fusion_list.
# Each fusion file will contain several pickles.
#
seed_list = mfunc.read_fusion_pickles(fusion_files)
#
# Given a list of seeds, fill a tensor with counts of the growth of colours
# generated by running the Management Game.
#
[tensor, num_seeds] = mfunc.growth_tensor(g, seed_list, step_size,
                      max_seeds, num_steps, num_colours, num_parts)
#
# now the tensor is full, so let's make the graph for 4 parts
#
graph_file = fusion_dir + "/fusion_pickles_prob_prod_4.txt"
graph_handle = open(graph_file, "w")
graph_handle.write("\n\nNOTE: {} Seeds -- {} Parts per seed\n\n".format(
  num_seeds, num_parts))
header = ["step num", \
  "4 managers and 0 workers", \
  "3 managers and 1 worker", \
  "2 managers and 2 workers", \
  "1 manager and 3 workers", \
  "0 managers and 4 workers", \
  "error bars for 4 managers and 0 workers", \
  "error bars for 3 managers and 1 workers", \
  "error bars for 2 managers and 2 workers", \
  "error bars for 1 manager and 3 worker", \
  "error bars for 0 managers and 4 workers"]
graph_handle.write("\t".join(header) + "\n")
#
for step_num in range(0, num_steps, step_size):
  # initialize growth
  growth_4m0w = [] # 4 managers, 0 workers
  growth_3m1w = [] # 3 managers, 1 worker
  growth_2m2w = [] # 2 managers, 2 workers
  growth_1m3w = [] # 1 manager,  3 workers
  growth_0m4w = [] # 0 managers, 4 workers
  # iterate over seed_num
  for seed_num in range(num_seeds):
    # iterate over parts
    manager_count = 0
    for part_num in range(num_parts):
      # extract colours
      red    = tensor[seed_num, step_num, 1, part_num]
      blue   = tensor[seed_num, step_num, 2, part_num]
      orange = tensor[seed_num, step_num, 3, part_num]
      green  = tensor[seed_num, step_num, 4, part_num]
      # we focus on the current part (part_num) only
      # -- the current part is always red, by convention
      red_manager = (orange > green) # true or false
      manager_count += red_manager # will increment by 0 or 1
      # calculate growth
      growth = red + blue + orange + green
      #
    # increment counts
    if (manager_count == 4):
      growth_4m0w.append(growth)
    elif (manager_count == 3):
      growth_3m1w.append(growth)
    elif (manager_count == 2):
      growth_2m2w.append(growth)
    elif (manager_count == 1):
      growth_1m3w.append(growth)
    else:
      growth_0m4w.append(growth)
  #
  # calculate stats for 4 managers, 0 workers (4m0w)
  if (len(growth_4m0w) > 1) and (step_num > 0):
    probability_4m0w  = len(growth_4m0w) / num_seeds
    prob_prod_4m0w    = [probability_4m0w * growth for growth in growth_4m0w]
    mean_pp_4m0w      = np.mean(prob_prod_4m0w)
    interval = st.t.interval(alpha=0.95, df=len(prob_prod_4m0w)-1, \
               loc=np.mean(prob_prod_4m0w), scale=st.sem(prob_prod_4m0w))
    error_bar_4m0w = (interval[1] - interval[0]) / 2.0
  else:
    mean_pp_4m0w    = 0.0
    error_bar_4m0w  = 0.0
  # calculate stats for 3 managers, 1 workers (3m1w)
  if (len(growth_3m1w) > 1) and (step_num > 0):
    probability_3m1w  = len(growth_3m1w) / num_seeds
    prob_prod_3m1w    = [probability_3m1w * growth for growth in growth_3m1w]
    mean_pp_3m1w      = np.mean(prob_prod_3m1w)
    interval = st.t.interval(alpha=0.95, df=len(prob_prod_3m1w)-1, \
               loc=np.mean(prob_prod_3m1w), scale=st.sem(prob_prod_3m1w))
    error_bar_3m1w = (interval[1] - interval[0]) / 2.0
  else:
    mean_pp_3m1w    = 0.0
    error_bar_3m1w  = 0.0
  # calculate stats for 2 managers, 2 workers (2m2w)
  if (len(growth_2m2w) > 1) and (step_num > 0):
    probability_2m2w  = len(growth_2m2w) / num_seeds
    prob_prod_2m2w    = [probability_2m2w * growth for growth in growth_2m2w]
    mean_pp_2m2w      = np.mean(prob_prod_2m2w)
    interval = st.t.interval(alpha=0.95, df=len(prob_prod_2m2w)-1, \
               loc=np.mean(prob_prod_2m2w), scale=st.sem(prob_prod_2m2w))
    error_bar_2m2w = (interval[1] - interval[0]) / 2.0
  else:
    mean_pp_2m2w    = 0.0
    error_bar_2m2w  = 0.0
  # calculate stats for 1 manager,  3 worker (1m3w)
  if (len(growth_1m3w) > 1) and (step_num > 0):
    probability_1m3w  = len(growth_1m3w) / num_seeds
    prob_prod_1m3w    = [probability_1m3w * growth for growth in growth_1m3w]
    mean_pp_1m3w      = np.mean(prob_prod_1m3w)
    interval = st.t.interval(alpha=0.95, df=len(prob_prod_1m3w)-1, \
               loc=np.mean(prob_prod_1m3w), scale=st.sem(prob_prod_1m3w))
    error_bar_1m3w = (interval[1] - interval[0]) / 2.0
  else:
    mean_pp_1m3w    = 0.0
    error_bar_1m3w  = 0.0
  # calculate stats for 0 managers, 4 workers (0m4w)
  if (len(growth_0m4w) > 1) and (step_num > 0):
    probability_0m4w  = len(growth_0m4w) / num_seeds
    prob_prod_0m4w    = [probability_0m4w * growth for growth in growth_0m4w]
    mean_pp_0m4w      = np.mean(prob_prod_0m4w)
    interval = st.t.interval(alpha=0.95, df=len(prob_prod_0m4w)-1, \
               loc=np.mean(prob_prod_0m4w), scale=st.sem(prob_prod_0m4w))
    error_bar_0m4w = (interval[1] - interval[0]) / 2.0
  else:
    mean_pp_0m4w    = 0.0
    error_bar_0m4w  = 0.0
  #
  graph_handle.write(("{}\t{:.3f}\t{:.3f}\t{:.3f}\t{:.3f}\t{:.3f}" +
    "\t{:.3f}\t{:.3f}\t{:.3f}\t{:.3f}\t{:.3f}\n").format(
    step_num, mean_pp_4m0w, mean_pp_3m1w, mean_pp_2m2w, mean_pp_1m3w, mean_pp_0m4w,
    error_bar_4m0w, error_bar_3m1w, error_bar_2m2w, error_bar_1m3w, error_bar_0m4w))
  #
#
graph_handle.close()
#
#